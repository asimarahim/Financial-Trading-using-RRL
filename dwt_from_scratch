import numpy as np

def dwt(signal):
    """Performs a one-level discrete wavelet transform (DWT) on the input signal using the Haar wavelet."""
    # make sure the signal length is a power of two
    n = len(signal)
    if not (n > 1 and ((n & (n - 1)) == 0)):
        raise ValueError("Signal length must be a power of two")

    # divide the signal into even and odd components
    even = (signal[::2] + signal[1::2]) / np.sqrt(2)
    odd = (signal[::2] - signal[1::2]) / np.sqrt(2)

    # concatenate the components in the following order: [even, odd]
    coeffs = np.concatenate((even, odd))

    return coeffs

def idwt(coeffs):
    """Performs an inverse discrete wavelet transform (IDWT) on the input coefficients using the Haar wavelet."""
    # make sure the number of coefficients is even
    n = len(coeffs)
    if n % 2 != 0:
        raise ValueError("Number of coefficients must be even")

    # extract the even and odd components from the coefficients
    m = n // 2
    even = coeffs[:m]
    odd = coeffs[m:]

    # calculate the reconstructed signal by adding and subtracting the even and odd components
    signal = np.zeros(n)
    signal[::2] = (even + odd) / np.sqrt(2)
    signal[1::2] = (even - odd) / np.sqrt(2)

    return signal

# example usage
signal = np.random.randn(8)
print("Signal:", signal)

# perform DWT
coeffs = dwt(signal)
print("Wavelet coefficients:", coeffs)

# perform IDWT
reconstructed_signal = idwt(coeffs)
print("Reconstructed signal:", reconstructed_signal)
